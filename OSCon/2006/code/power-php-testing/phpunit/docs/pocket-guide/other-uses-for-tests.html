<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><title>Chapter 11. Other Uses for Tests</title><link rel="stylesheet" href="docbook.css" type="text/css"></link><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"></meta><link rel="start" href="index.html" title="PHPUnit Pocket Guide"></link><link rel="up" href="index.html" title="PHPUnit Pocket Guide"></link><link rel="prev" href="stubs.html" title="Chapter 10. Stubs"></link><link rel="next" href="phing.html" title="Chapter 12. PHPUnit and Phing"></link><script xmlns="" src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script><script xmlns="" type="text/javascript">_uacct = "UA-68261-2";urchinTracker();</script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 11. Other Uses for Tests</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="stubs.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="phing.html">Next</a></td></tr></table><hr></hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="other-uses-for-tests"></a>Chapter 11. Other Uses for Tests</h2></div></div></div><p>
    Once you get used to writing automated tests, you will likely discover
    more uses for tests. Here are some examples.
  </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="other-uses-for-tests.agile-documentation"></a>Agile Documentation</h2></div></div></div><p>
      <a id="id401733" class="indexterm"></a>
      <a id="id401740" class="indexterm"></a>
      <a id="id401747" class="indexterm"></a>
      <a id="id401664" class="indexterm"></a>

      Typically, in a project that is developed using an agile process,
      such as Extreme Programming, the documentation cannot keep up with the
      frequent changes to the project's design and code. Extreme Programming
      demands <span class="emphasis"><em>collective code ownership</em></span>, so all
      developers need to know how the entire system works. If you are
      disciplined enough to consequently use "speaking names" for your tests
      that describe what a class should do, you can use PHPUnit's TestDox
      functionality to generate automated documentation for your project based
      on its tests. This documentation gives developers an overview of what
      each class of the project is supposed to do.
    </p><p>
      PHPUnit's TestDox functionality looks at a test class and all the test
      method names and converts them from camel case PHP names to sentences:
      <code class="literal">testBalanceIsInitiallyZero()</code> becomes "Balance is
      initially zero". If there are several test methods whose names only
      differ in a suffix of one or more digits, such as
      <code class="literal">testBalanceCannotBecomeNegative()</code> and
      <code class="literal">testBalanceCannotBecomeNegative2()</code>, the sentence
      "Balance cannot become negative" will appear only once, assuming that
      all of these tests succeed.
    </p><p>
      The following code shows the agile documentation for the
      <code class="literal">BankAccount</code> class (from
      <a href="test-first-programming.html#test-first-programming.bankaccount-example.examples.BankAccountTest.php" title="Example 8.1: Tests for the BankAccount class">Example 8.1</a>)
      generated by running <strong class="userinput"><code>phpunit --testdox-text BankAccountTest.txt BankAccountTest</code></strong>:
    </p><pre class="screen">BankAccount
 - Balance is initially zero
 - Balance cannot become negative</pre><p>
      Alternatively, the agile documentation can be generated in HTML format
      by using <code class="literal">--testdox-html BankAccountTest.htm</code>.
    </p><p>
      <a id="id402320" class="indexterm"></a>

      Agile Documentation can be used to document the assumptions you make
      about the external packages that you use in your project. When you use
      an external package, you are exposed to the risks that the package will
      not behave as you expect, and that future versions of the package will
      change in subtle ways that will break your code, without you knowing it.
      You can address these risks by writing a test every time you make an
      assumption. If your test succeeds, your assumption is valid. If you
      document all your assumptions with tests, future releases of the
      external package will be no cause for concern: if the tests succeed,
      your system should continue working.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="other-uses-for-tests.cross-team-tests"></a>Cross-Team Tests</h2></div></div></div><p>
      When you document assumptions with tests, you own the tests. The
      supplier of the package -- who you make assumptions about -- knows
      nothing about your tests. If you want to have a closer relationship
      with the supplier of a package, you can use the tests to communicate
      and coordinate your activities.
    </p><p>
      When you agree on coordinating your activities with the supplier of a
      package, you can write the tests together. Do this in such a way that
      the tests reveal as many assumptions as possible. Hidden assumptions are
      the death of cooperation. With the tests, you document exactly what you
      expect from the supplied package. The supplier will know the package is
      complete when all the tests run.
    </p><p>
      <a id="id402705" class="indexterm"></a>

      By using stubs (see the section "Stubs", earlier in this book), you can
      further decouple yourself from the supplier: The job of the supplier is
      to make the tests run with the real implementation of the package. Your
      job is to make the tests run for your own code. Until such time as you
      have the real implementation of the supplied package, you use stub
      objects. Following this approach, the two teams can develop
      independently.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="other-uses-for-tests.debugging-tests"></a>Debugging Tests</h2></div></div></div><p>
      When you get a defect report, your impulse might be to fix the defect as
      quickly as possible. Experience shows that this impulse will not serve
      you well; it is likely that the fix for the defect causes another
      defect.
    </p><p>
      You can hold your impulse in check by doing the following:
    </p><div class="orderedlist"><ol type="1"><li><p>
          Verifying that you can reproduce the defect.
        </p></li><li><p>
          Finding the smallest-scale demonstration of the defect in the code.
          For example, if a number appears incorrectly in an output, find the
          object that is computing that number.
        </p></li><li><p>
          Writing an automated tests that fails but will succeed when the
          defect is fixed.
        </p></li><li><p>
          Fixing the defect.
        </p></li></ol></div><p>
      Finding the smallest reliable reproduction of the defect gives you the
      opportunity to really examine the cause of the defect. The test you
      write will improve the chances that when you fix the defect, you really
      fix it, because the new test reduces the likelihood of undoing the fix
      with future code changes. All the tests you wrote before reduce the
      likelihood of inadvertently causing a different problem.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="other-uses-for-tests.refactoring"></a>Refactoring</h2></div></div></div><p>
      <a id="id402809" class="indexterm"></a>

      Refactoring, the controlled technique for improving the design of an
      existing code base, can be applied safely only when you have a test
      suite. Otherwise, you might not notice the system breaking while you are
      carrying out the restructuring. Refactoring can be broken down into
      a series of small behavior-preserving transformations.
    </p><p>
      The following conditions will help you to improve the code and design
      of your project, while using unit tests to verify that the refactoring's
      transformation steps are, indeed, behavior-preserving and do not
      introduce errors:
    </p><div class="orderedlist"><ol type="1"><li><p>All unit tests run correctly.</p></li><li><p>The code communicates its design principles.</p></li><li><p>The code contains no redundancies.</p></li><li><p>The code contains the minimal number of classes and methods.</p></li></ol></div></div></div><div class="navfooter"><hr></hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="stubs.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="phing.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 10. Stubs </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 12. PHPUnit and Phing</td></tr></table></div><div xmlns="" class="copyright-notice"><a href="appendixes.copyright.html">Copyright</a> © 2005 <a href="http://www.sebastian-bergmann.de/">Sebastian Bergmann</a>
      and <a href="http://www.oreilly.com/">O'Reilly Media, Inc.</a>.
    </div></body></html>
